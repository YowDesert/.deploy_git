<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YowDesert&#39;s 資訊學習筆記</title>
  
  <subtitle>一起從零開始踏進資訊世界</subtitle>
  <link href="https://yowdesert.github.io/atom.xml" rel="self"/>
  
  <link href="https://yowdesert.github.io/"/>
  <updated>2025-08-14T04:56:53.949Z</updated>
  <id>https://yowdesert.github.io/</id>
  
  <author>
    <name>YowDesert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 題目統整筆記</title>
    <link href="https://yowdesert.github.io/posts/leetcode_summary.html"/>
    <id>https://yowdesert.github.io/posts/leetcode_summary.html</id>
    <published>2025-08-14T04:00:00.000Z</published>
    <updated>2025-08-14T04:56:53.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章統整了我練習過的 LeetCode 題目，並按照 <strong>難度、題型、演算法分類</strong> 來整理，方便快速查找與回顧。  </p><p>每個題目都會提供：</p><ul><li>題目編號與名稱</li><li>難度</li><li>題型或演算法主題</li><li>筆記連結（若有）</li></ul><hr><h2 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h2><ol><li><a href="#easy">Easy 題目</a></li><li><a href="#medium">Medium 題目</a></li><li><a href="#hard">Hard 題目</a></li><li><a href="#%E6%BC%94%E7%AE%97%E6%B3%95%E5%88%86%E9%A1%9E">演算法分類</a></li></ol><hr><ul><li>Dynamic Programming</li><li>Math</li><li>Memoization</li></ul><h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><table><thead><tr><th>題號</th><th>題目名稱</th><th>題型 &#x2F; 演算法</th><th>筆記連結</th></tr></thead><tbody><tr><td>70</td><td>Climbing Stairs</td><td>Dynamic Programming &#x2F; Fibonacci</td><td><a href="./70climb">筆記</a></td></tr><tr><td>2264</td><td>Largest 3-Same-Digit Number in String</td><td>String &#x2F; Simulation</td><td><a href="./227e4073">筆記</a></td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><hr><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><table><thead><tr><th>題號</th><th>題目名稱</th><th>題型 &#x2F; 演算法</th><th>筆記連結</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><hr><h2 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h2><table><thead><tr><th>題號</th><th>題目名稱</th><th>題型 &#x2F; 演算法</th><th>筆記連結</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><hr><h2 id="演算法分類"><a href="#演算法分類" class="headerlink" title="演算法分類"></a>演算法分類</h2><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><ul><li><ol start="70"><li>Climbing Stairs (<a href="./70climb">筆記</a>)</li></ol></li><li>…</li></ul><h3 id="String-Simulation"><a href="#String-Simulation" class="headerlink" title="String &#x2F; Simulation"></a>String &#x2F; Simulation</h3><ul><li><ol start="2264"><li>Largest 3-Same-Digit Number in String (<a href="./227e4073">筆記</a>)</li></ol></li><li>…</li></ul><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul><li><ol start="70"><li>Climbing Stairs (<a href="./70climb">筆記</a>)</li></ol></li><li>…</li></ul><h3 id="Graph-BFS-DFS"><a href="#Graph-BFS-DFS" class="headerlink" title="Graph &#x2F; BFS &#x2F; DFS"></a>Graph &#x2F; BFS &#x2F; DFS</h3><ul><li>…</li></ul><h3 id="Sorting-Heap-Priority-Queue"><a href="#Sorting-Heap-Priority-Queue" class="headerlink" title="Sorting &#x2F; Heap &#x2F; Priority Queue"></a>Sorting &#x2F; Heap &#x2F; Priority Queue</h3><ul><li>…</li></ul><h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><ul><li>…</li></ul><h3 id="Weekly-Contest-292"><a href="#Weekly-Contest-292" class="headerlink" title="Weekly Contest 292"></a>Weekly Contest 292</h3><ul><li><ol start="2264"><li>Largest 3-Same-Digit Number in String (<a href="./227e4073">筆記</a>)</li></ol></li><li>…</li></ul><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這份統整筆記的目的：</p><ol><li>快速查找已做過的題目與筆記  </li><li>根據演算法主題分類，加深對各種技巧的理解  </li><li>幫助規劃未來練習的題目順序</li></ol><p>未來可以持續更新，將新的題目依難度和演算法分類加入，形成完整的 LeetCode 題目總表。</p>]]></content>
    
    
    <summary type="html">LeetCode 題目統整，依照難度、類型、演算法分類整理，方便查閱。</summary>
    
    
    
    <category term="LeetCode" scheme="https://yowdesert.github.io/categories/LeetCode/"/>
    
    <category term="所有題目分類" scheme="https://yowdesert.github.io/categories/LeetCode/%E6%89%80%E6%9C%89%E9%A1%8C%E7%9B%AE%E5%88%86%E9%A1%9E/"/>
    
    
    <category term="LeetCode" scheme="https://yowdesert.github.io/tags/LeetCode/"/>
    
    <category term="練習題整理" scheme="https://yowdesert.github.io/tags/%E7%B7%B4%E7%BF%92%E9%A1%8C%E6%95%B4%E7%90%86/"/>
    
    <category term="演算法分類" scheme="https://yowdesert.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95%E5%88%86%E9%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 70題 Climbing Stairs 解題筆記</title>
    <link href="https://yowdesert.github.io/posts/70climb.html"/>
    <id>https://yowdesert.github.io/posts/70climb.html</id>
    <published>2025-08-14T03:30:00.000Z</published>
    <updated>2025-08-14T04:49:32.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>你正在爬樓梯，需要 <code>n</code> 步才能到達頂端。<br>每次你可以爬 <strong>1 或 2 步</strong>。  </p><p>請問你有多少種不同的方法可以爬到頂端？</p><hr><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p><strong>範例 1：</strong><br>輸入：n &#x3D; 2<br>輸出：2<br>解釋：有兩種方法可以爬到頂端：</p><ol><li>1 步 + 1 步  </li><li>2 步</li></ol><p><strong>範例 2：</strong><br>輸入：n &#x3D; 3<br>輸出：3<br>解釋：有三種方法可以爬到頂端：</p><ol><li>1 步 + 1 步 + 1 步  </li><li>1 步 + 2 步  </li><li>2 步 + 1 步</li></ol><hr><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 45</li></ul><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><ol><li>這題是典型的 <strong>動態規劃 (DP)</strong> 題目。  </li><li>定義 <code>dp[i]</code> 表示爬到第 <code>i</code> 階的方法數。  </li><li>狀態轉移方程：<br>[<br>dp[i] &#x3D; dp[i-1] + dp[i-2]<br>]<br>因為到第 i 階可以從 i-1 或 i-2 走一步到達。  </li><li>初始化：<ul><li><code>dp[1] = 1</code> (只有一種方法爬到第一階)  </li><li><code>dp[2] = 2</code> (兩種方法爬到第二階：1+1 或 2)</li></ul></li><li>遞迴或迴圈都可以實作。</li></ol><h2 id="範例解題-範例一"><a href="#範例解題-範例一" class="headerlink" title="範例解題 - 範例一"></a>範例解題 - 範例一</h2><p>以 “9” 格樓梯作為例，我們可以用 <strong>DP 表</strong> 來表示爬到每一階的方法數：</p><table><thead><tr><th>i (階數)</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>dp[i]</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td></tr></tbody></table><h3 id="表格說明："><a href="#表格說明：" class="headerlink" title="表格說明："></a>表格說明：</h3><ol><li><code>dp[1] = 1</code>：爬到第 1 階只有 1 種方法 → <code>[1]</code>  </li><li><code>dp[2] = 2</code>：爬到第 2 階有 2 種方法 → <code>[1+1], [2]</code>  </li><li><code>dp[i] = dp[i-1] + dp[i-2]</code>：第 i 階可以從 i-1 階走 1 步或從 i-2 階走 2 步，因此方法數相加。</li></ol><hr><h3 id="每階方法拆解"><a href="#每階方法拆解" class="headerlink" title="每階方法拆解"></a>每階方法拆解</h3><h4 id="爬到第-1-階："><a href="#爬到第-1-階：" class="headerlink" title="爬到第 1 階："></a>爬到第 1 階：</h4><ul><li>方法數：1  </li><li>拆解：<code>[1]</code></li></ul><h4 id="爬到第-2-階："><a href="#爬到第-2-階：" class="headerlink" title="爬到第 2 階："></a>爬到第 2 階：</h4><ul><li>方法數：2  </li><li>拆解：<ol><li><code>[1 + 1]</code>  </li><li><code>[2]</code></li></ol></li></ul><h4 id="爬到第-3-階："><a href="#爬到第-3-階：" class="headerlink" title="爬到第 3 階："></a>爬到第 3 階：</h4><ul><li>方法數：3 (<code>dp[3] = dp[2] + dp[1] = 2 + 1</code>)  </li><li>拆解：<ol><li>從第 2 階走 1 步：<code>[1 + 1] + 1 = [1 + 1 + 1]</code>  </li><li>從第 1階走 2 步：<code>[1] + 2 = [1 + 2]</code>  </li><li>從第 1階走 2 步（另一種順序）：<code>[2] + 1 = [2 + 1]</code></li></ol></li></ul><h4 id="爬到第-4-階："><a href="#爬到第-4-階：" class="headerlink" title="爬到第 4 階："></a>爬到第 4 階：</h4><ul><li>方法數：5 (<code>dp[4] = dp[3] + dp[2] = 3 + 2</code>)  </li><li>拆解：<ol><li>從第 3 階走 1 步：<ul><li><code>[1+1+1] + 1 = [1+1+1+1]</code>  </li><li><code>[1+2] + 1 = [1+2+1]</code>  </li><li><code>[2+1] + 1 = [2+1+1]</code></li></ul></li><li>從第 2 階走 2 步：<ul><li><code>[1+1] + 2 = [1+1+2]</code>  </li><li><code>[2] + 2 = [2+2]</code></li></ul></li></ol></li></ul><h4 id="爬到第-5-階："><a href="#爬到第-5-階：" class="headerlink" title="爬到第 5 階："></a>爬到第 5 階：</h4><ul><li>方法數：8 (<code>dp[5] = dp[4] + dp[3] = 5 + 3</code>)  </li><li>拆解：<ul><li>從第 4 階走 1 步：<code>[1+1+1+1]+1, [1+2+1]+1, [2+1+1]+1, [1+1+2]+1, [2+2]+1</code>  </li><li>從第 3 階走 2 步：<code>[1+1+1]+2, [1+2]+2, [2+1]+2</code></li></ul></li></ul><h4 id="爬到第-6-階："><a href="#爬到第-6-階：" class="headerlink" title="爬到第 6 階："></a>爬到第 6 階：</h4><ul><li>方法數：13 (<code>dp[6] = dp[5] + dp[4] = 8 + 5</code>)  </li><li>拆解：<ul><li>從第 5 階走 1 步：將 dp[5] 每種方法加上 1  </li><li>從第 4 階走 2 步：將 dp[4] 每種方法加上 2</li></ul></li></ul><p>依此類推，直到第 9 階，最終：</p><ul><li><code>dp[9] = 55</code>  </li><li>表示爬 9 階樓梯總共有 <strong>55 種不同方法</strong></li></ul><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><ol><li>每階方法數 &#x3D; 上一階 + 上二階的方法數。  </li><li>DP 表格可以快速查出任意階的總方法數。</li></ol><hr><h2 id="參考程式碼（C-範例）"><a href="#參考程式碼（C-範例）" class="headerlink" title="參考程式碼（C++ 範例）"></a>參考程式碼（C++ 範例）</h2><pre><code class="language-cpp">class Solution&#123;public:    int Stairs(int n, int dp[])    &#123;        // 特殊情況：當 n = 3 時，直接計算 dp[3] = dp[1] + dp[2]        if (n == 3)        &#123;            dp[3] = dp[1] + dp[2];            return dp[3];        &#125;        // 遞迴呼叫計算前一階的方法數，確保 dp[n-1] 已計算        Stairs(n - 1, dp);        // 第 n 階的方法數 = 前一階 + 前兩階的方法數        dp[n] = dp[n - 1] + dp[n - 2];        return dp[n];     &#125;    int climbStairs(int n)    &#123;        // 初始陣列50格 因為題目只限制到45 開50不多不少        int dp[50] = &#123;0&#125;;        // 初始化 一格 兩格        dp[1] = 1;        dp[2] = 2;        if (n &lt;= 2)        &#123;            return dp[n];        &#125;        Stairs(n, dp);        return dp[n];    &#125;&#125;;---## 複雜度分析- **時間複雜度**：O(n)- **空間複雜度**：O(1)---## LeetCode 成績- Runtime：0 ms — Beats 100% of C++ users- Memory：7.85 MB — Beats 73.07% of C++ users---## 補充說明我的解法不一定是最佳解，  但我會盡可能去思考、調整，  朝著最佳解的方向努力。  如果有想要補充的歡迎在下面評論區補充歐 !</code></pre>]]></content>
    
    
    <summary type="html">LeetCode 70 題 Climbing Stairs 題目翻譯、範例與解法整理。</summary>
    
    
    
    <category term="LeetCode" scheme="https://yowdesert.github.io/categories/LeetCode/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/LeetCode/Easy/"/>
    
    
    <category term="Easy" scheme="https://yowdesert.github.io/tags/Easy/"/>
    
    <category term="LeetCode" scheme="https://yowdesert.github.io/tags/LeetCode/"/>
    
    <category term="Dynamic Programming" scheme="https://yowdesert.github.io/tags/Dynamic-Programming/"/>
    
    <category term="Math" scheme="https://yowdesert.github.io/tags/Math/"/>
    
    <category term="Memoization" scheme="https://yowdesert.github.io/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2264題 Largest 3-Same-Digit Number in String 解題筆記</title>
    <link href="https://yowdesert.github.io/posts/227e4073.html"/>
    <id>https://yowdesert.github.io/posts/227e4073.html</id>
    <published>2025-08-14T03:00:00.000Z</published>
    <updated>2025-08-14T04:25:21.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目描述"><a href="#題目描述" class="headerlink" title="題目描述"></a>題目描述</h2><p>你會得到一個字串 <code>num</code>，表示一個大型整數。<br>一個整數被稱為 <strong>good integer</strong>，如果它符合以下條件：</p><ol><li>它是 <code>num</code> 的長度為 3 的子字串。</li><li>它只由 <strong>一個唯一數字</strong> 構成（例如 <code>777</code>、<code>000</code>）。</li><li>回傳最大的 good integer（以字串形式），如果不存在則回傳空字串 <code>&quot;&quot;</code>。</li></ol><hr><p><strong>注意：</strong></p><ul><li>子字串是字串中一段連續的字元序列。</li><li><code>num</code> 或 good integer 可能包含前導零。</li></ul><hr><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p><strong>範例 1：</strong><br>輸入：num &#x3D; “6777133339”<br>輸出：”777”<br>解釋：存在兩個 good integer：”777” 和 “333”，其中 “777” 最大，因此回傳 “777”。</p><p><strong>範例 2：</strong><br>輸入：num &#x3D; “2300019”<br>輸出：”000”<br>解釋：”000” 是唯一的 good integer。</p><p><strong>範例 3：</strong><br>輸入：num &#x3D; “42352338”<br>輸出：””<br>解釋：不存在長度為 3 且由單一數字構成的子字串。</p><hr><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><ul><li><code>3 &lt;= num.length &lt;= 1000</code></li><li><code>num</code> 只包含數字 <code>0-9</code></li></ul><hr><h2 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h2><ol><li><p>固定長度 3，一次掃過字串。</p></li><li><p>視窗內三個字元若相同，就更新目前最大字元。</p></li><li><p>走完後把最大字元複製 3 次回傳；沒找到就回傳空字串。</p></li></ol><h2 id="範例解題-範例一"><a href="#範例解題-範例一" class="headerlink" title="範例解題 - 範例一"></a>範例解題 - 範例一</h2><p>以範例一 <code>num = &quot;6777133339&quot;</code> 為例，示意滑動長度為 3 的檢查過程：</p><ol><li><p><strong>起始視窗</strong> → “<code>[6 7 7]</code> 7 1 3 3 3 3 9”</p><ul><li>三個字元不相同 → 略過  </li><li><code>bestAns = 0</code>（尚未找到）</li></ul></li><li><p><strong>視窗右移 1</strong> → “6 <code>[7 7 7]</code> 1 3 3 3 3 9”</p><ul><li>三個字元相同 (777) → 比較 bestAns &#x3D; 0 &lt; ‘7’(字元7 ASCII碼為55)  → 更新 <code>bestAns = &#39;7&#39;</code></li></ul></li><li><p><strong>視窗右移 1</strong> → “6 7 <code>[7 7 1]</code> 3 3 3 3 9”  </p><ul><li>不相同 → bestAns 維持 ‘7’</li></ul></li><li><p><strong>視窗右移 1</strong> → “6 7 7 <code>[7 1 3]</code> 3 3 3 9”  </p><ul><li>不相同 → bestAns 維持 ‘7’</li></ul></li><li><p><strong>視窗右移 1</strong> → “6 7 7 7 <code>[1 3 3]</code> 3 3 9”   </p><ul><li>不相同 → bestAns 維持 ‘7’</li></ul></li><li><p><strong>視窗右移 1</strong> → “6 7 7 7 1 <code>[3 3 3]</code> 3 9”   </p><ul><li>三個字元相同 (333) → 比較 <code>&#39;3&#39;</code> 與 <code>&#39;7&#39;</code>，<code>&#39;7&#39; 較大</code> → 不更新</li></ul></li><li><p><strong>視窗右移 1</strong> → “6 7 7 7 1 3 <code>[3 3 3]</code> 9”    </p><ul><li>三個字元相同 (333) → 比較 ‘3’ 與 ‘7’，不更新</li></ul></li></ol><p><strong>最終結果</strong>：<code>bestAns = &#39;7&#39;</code> → 回傳 <code>&quot;777&quot;</code></p><hr><h2 id="參考程式碼（C-範例）"><a href="#參考程式碼（C-範例）" class="headerlink" title="參考程式碼（C++ 範例）"></a>參考程式碼（C++ 範例）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestGoodInteger</span><span class="params">(string num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化最佳解為 ASCII = 0 (ASCII = 0 為 Null)</span></span><br><span class="line">        <span class="type">char</span> bestAns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//從陣列開頭開始 、 如果 i + 2那個位置 &gt;= num 陣列大小則結束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判斷i 、 i+1 、 i+2 這三個數值一樣</span></span><br><span class="line">            <span class="keyword">if</span> (num[i] == num[i + <span class="number">1</span>] &amp;&amp; num[i] == num[i + <span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判斷這組連續的值 是否比歷史最大的值大</span></span><br><span class="line">                <span class="keyword">if</span> (num[i] &gt; bestAns)</span><br><span class="line">                    bestAns = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 bestAns 仍為 0，表示沒有任何符合的長度 3 子字串</span></span><br><span class="line">        <span class="comment">// 如果有答案就回傳 string(3, bestAns) (建立一個長度為 3，每個位置都放 bestAns 這個字元的字串。)</span></span><br><span class="line">        <span class="comment">// 如果沒有 回傳 空字串</span></span><br><span class="line">        <span class="keyword">return</span> bestAns ? <span class="built_in">string</span>(<span class="number">3</span>, bestAns) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="複雜度分析"><a href="#複雜度分析" class="headerlink" title="複雜度分析"></a>複雜度分析</h2><ul><li><strong>時間複雜度</strong>：O(n)</li><li><strong>空間複雜度</strong>：O(1)</li></ul><hr><h2 id="LeetCode-成績"><a href="#LeetCode-成績" class="headerlink" title="LeetCode 成績"></a>LeetCode 成績</h2><ul><li>Runtime：0 ms — Beats 100% of C++ users</li><li>Memory：9 MB — Beats 77.37% of C++ users</li></ul><hr><h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><p>這題我的解法不一定是最佳解，<br>但我會盡可能去思考、調整，<br>朝著最佳解的方向努力。<br>如果有想要補充的歡迎在下面評論區補充歐 !</p><p>還有ASCII碼表為<br><img src="/img/image.png" alt="alt text"></p>]]></content>
    
    
    <summary type="html">LeetCode 2264 題 Largest 3-Same-Digit Number in String 題目翻譯、範例與解法整理。</summary>
    
    
    
    <category term="LeetCode" scheme="https://yowdesert.github.io/categories/LeetCode/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/LeetCode/Easy/"/>
    
    
    <category term="String" scheme="https://yowdesert.github.io/tags/String/"/>
    
    <category term="Weekly Contest 292" scheme="https://yowdesert.github.io/tags/Weekly-Contest-292/"/>
    
    <category term="LeetCode" scheme="https://yowdesert.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[離散數學] 基本符號與概念速查表</title>
    <link href="https://yowdesert.github.io/posts/69c95243.html"/>
    <id>https://yowdesert.github.io/posts/69c95243.html</id>
    <published>2025-08-12T07:00:00.000Z</published>
    <updated>2025-08-14T07:05:41.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>📚 <strong>這篇文章是離散數學符號速查表</strong><br>沒有艱澀推導，只要你想查「某個符號是什麼意思」，打開這篇就夠了！</p></blockquote><hr><h2 id="1-邏輯運算符號"><a href="#1-邏輯運算符號" class="headerlink" title="1. 邏輯運算符號"></a>1. 邏輯運算符號</h2><table><thead><tr><th>符號</th><th>名稱</th><th>意義（白話版）</th><th>KaTeX</th></tr></thead><tbody><tr><td>$\lnot p$</td><td>否定</td><td>把 p 的真假顛倒</td><td><code>\lnot p</code></td></tr><tr><td>$p \land q$</td><td>且 (AND)</td><td>p 和 q 都要對才成立</td><td><code>p \land q</code></td></tr><tr><td>$p \lor q$</td><td>或 (OR)</td><td>p 或 q 任一對就成立</td><td><code>p \lor q</code></td></tr><tr><td>$p \oplus q$</td><td>互斥或 (XOR)</td><td>只能有一個對</td><td><code>p \oplus q</code></td></tr><tr><td>$p \to q$</td><td>蘊涵</td><td>p 對 → q 也必須對</td><td><code>p \to q</code></td></tr><tr><td>$p \leftrightarrow q$</td><td>等價</td><td>p 和 q 要同進同退</td><td><code>p \leftrightarrow q</code></td></tr><tr><td>$\top$</td><td>永真</td><td>永遠對</td><td><code>\top</code></td></tr><tr><td>$\bot$</td><td>永假</td><td>永遠錯</td><td><code>\bot</code></td></tr><tr><td>$\forall x$</td><td>全稱量詞</td><td>對所有 x 都成立</td><td><code>\forall x</code></td></tr><tr><td>$\exists x$</td><td>存在量詞</td><td>至少有一個 x 成立</td><td><code>\exists x</code></td></tr><tr><td>$\nexists x$</td><td>不存在量詞</td><td>沒有任何 x 成立</td><td><code>\nexists x</code></td></tr></tbody></table><hr><h2 id="2-集合運算符號"><a href="#2-集合運算符號" class="headerlink" title="2. 集合運算符號"></a>2. 集合運算符號</h2><table><thead><tr><th>符號</th><th>名稱</th><th>意義（白話版）</th><th>KaTeX</th></tr></thead><tbody><tr><td>$a \in A$</td><td>屬於</td><td>a 是 A 裡的一員</td><td><code>a \in A</code></td></tr><tr><td>$a \notin A$</td><td>不屬於</td><td>a 不在 A 裡</td><td><code>a \notin A</code></td></tr><tr><td>$A \subset B$</td><td>真子集</td><td>A 完全包含在 B 裡，但不等於 B</td><td><code>A \subset B</code></td></tr><tr><td>$A \subseteq B$</td><td>子集</td><td>A 在 B 裡（可能相等）</td><td><code>A \subseteq B</code></td></tr><tr><td>$A \nsubseteq B$</td><td>不是子集</td><td>A 有元素不在 B 裡</td><td><code>A \nsubseteq B</code></td></tr><tr><td>$A \supset B$</td><td>真超集</td><td>A 比 B 大且包含它</td><td><code>A \supset B</code></td></tr><tr><td>$A \supseteq B$</td><td>超集</td><td>A 包含 B（可能相等）</td><td><code>A \supseteq B</code></td></tr><tr><td>$A \cup B$</td><td>聯集</td><td>A 和 B 的全部元素</td><td><code>A \cup B</code></td></tr><tr><td>$A \cap B$</td><td>交集</td><td>A 和 B 的共同元素</td><td><code>A \cap B</code></td></tr><tr><td>$\emptyset$</td><td>空集合</td><td>什麼都沒有</td><td><code>\emptyset</code></td></tr><tr><td>$A - B$</td><td>差集</td><td>在 A 但不在 B</td><td><code>A - B</code></td></tr><tr><td>$A \times B$</td><td>笛卡兒積</td><td>所有 $(a,b)$ 配對</td><td><code>A \times B</code></td></tr><tr><td>$\mathcal{P}(A)$</td><td>冪集</td><td>A 的所有子集組成的集合</td><td><code>\mathcal&#123;P&#125;(A)</code></td></tr></tbody></table><hr><h2 id="3-數系符號"><a href="#3-數系符號" class="headerlink" title="3. 數系符號"></a>3. 數系符號</h2><table><thead><tr><th>符號</th><th>名稱</th><th>意義</th><th>KaTeX</th></tr></thead><tbody><tr><td>$\mathbb{N}$</td><td>自然數</td><td>${0, 1, 2, \dots}$ 或 ${1, 2, \dots}$（看定義）</td><td><code>\mathbb&#123;N&#125;</code></td></tr><tr><td>$\mathbb{Z}$</td><td>整數</td><td>${\dots, -2, -1, 0, 1, \dots}$</td><td><code>\mathbb&#123;Z&#125;</code></td></tr><tr><td>$\mathbb{Q}$</td><td>有理數</td><td>能寫成 $\frac{p}{q}$，$q \neq 0$</td><td><code>\mathbb&#123;Q&#125;</code></td></tr><tr><td>$\mathbb{R}$</td><td>實數</td><td>所有實數</td><td><code>\mathbb&#123;R&#125;</code></td></tr><tr><td>$\mathbb{C}$</td><td>複數</td><td>$a + bi$ 形式</td><td><code>\mathbb&#123;C&#125;</code></td></tr><tr><td>$\mathbb{P}$</td><td>質數</td><td>大於 1 且只能被 1 和自己整除</td><td><code>\mathbb&#123;P&#125;</code></td></tr></tbody></table><hr><h2 id="4-關係與數論符號"><a href="#4-關係與數論符號" class="headerlink" title="4. 關係與數論符號"></a>4. 關係與數論符號</h2><table><thead><tr><th>符號</th><th>名稱</th><th>意義</th><th>KaTeX</th></tr></thead><tbody><tr><td>$&#x3D;$</td><td>等於</td><td>一模一樣</td><td><code>=</code></td></tr><tr><td>$\neq$</td><td>不等於</td><td>不一樣</td><td><code>\neq</code></td></tr><tr><td>$&lt;$</td><td>小於</td><td>左邊比右邊小</td><td><code>&lt;</code></td></tr><tr><td>$&gt;$</td><td>大於</td><td>左邊比右邊大</td><td><code>&gt;</code></td></tr><tr><td>$\leq$</td><td>小於等於</td><td>小或一樣</td><td><code>\leq</code></td></tr><tr><td>$\geq$</td><td>大於等於</td><td>大或一樣</td><td><code>\geq</code></td></tr><tr><td>$\equiv$</td><td>同餘</td><td>除 n 後餘數一樣</td><td><code>\equiv</code></td></tr><tr><td>$\not\equiv$</td><td>不同餘</td><td>除 n 後餘數不一樣</td><td><code>\not\equiv</code></td></tr><tr><td>$a \mid b$</td><td>可整除</td><td>a 能整除 b</td><td><code>a \mid b</code></td></tr><tr><td>$a \nmid b$</td><td>不可整除</td><td>a 不能整除 b</td><td><code>a \nmid b</code></td></tr><tr><td>$a \bmod n$</td><td>取模</td><td>除 n 後的餘數</td><td><code>a \bmod n</code></td></tr><tr><td>$\gcd(a,b)$</td><td>最大公因數</td><td>同時整除 a、b 的最大數</td><td><code>\gcd(a,b)</code></td></tr><tr><td>$\mathrm{lcm}(a,b)$</td><td>最小公倍數</td><td>同時被 a、b 整除的最小數</td><td><code>\mathrm&#123;lcm&#125;(a,b)</code></td></tr></tbody></table><hr><h2 id="5-其他常用數學符號"><a href="#5-其他常用數學符號" class="headerlink" title="5. 其他常用數學符號"></a>5. 其他常用數學符號</h2><table><thead><tr><th>符號</th><th>名稱</th><th>意義</th><th>KaTeX</th></tr></thead><tbody><tr><td>$\therefore$</td><td>所以</td><td>推論結果</td><td><code>\therefore</code></td></tr><tr><td>$\because$</td><td>因為</td><td>推論原因</td><td><code>\because</code></td></tr><tr><td>$\pm$</td><td>正負號</td><td>正或負</td><td><code>\pm</code></td></tr><tr><td>$\mp$</td><td>負正號</td><td>負或正</td><td><code>\mp</code></td></tr><tr><td>$\infty$</td><td>無窮</td><td>沒有盡頭</td><td><code>\infty</code></td></tr><tr><td>$\sqrt{x}$</td><td>平方根</td><td>x 的平方根</td><td><code>\sqrt&#123;x&#125;</code></td></tr><tr><td>$\lceil x \rceil$</td><td>向上取整</td><td>大於等於 x 的最小整數</td><td><code>\lceil x \rceil</code></td></tr><tr><td>$\lfloor x \rfloor$</td><td>向下取整</td><td>小於等於 x 的最大整數</td><td><code>\lfloor x \rfloor</code></td></tr><tr><td>$\Sigma$</td><td>總和符號</td><td>數列求和</td><td><code>\Sigma</code></td></tr><tr><td>$\Pi$</td><td>乘積符號</td><td>數列乘積</td><td><code>\Pi</code></td></tr><tr><td>$\bigwedge$</td><td>大寫 AND</td><td>多個命題的且</td><td><code>\bigwedge</code></td></tr><tr><td>$\bigvee$</td><td>大寫 OR</td><td>多個命題的或</td><td><code>\bigvee</code></td></tr><tr><td>$\bigcap$</td><td>大交集</td><td>多集合的交集</td><td><code>\bigcap</code></td></tr><tr><td>$\bigcup$</td><td>大聯集</td><td>多集合的聯集</td><td><code>\bigcup</code></td></tr></tbody></table><hr><h2 id="6-小範例"><a href="#6-小範例" class="headerlink" title="6. 小範例"></a>6. 小範例</h2><div class="note success flat"><p><strong>集合運算例子</strong><br>$$<br>A &#x3D; {1, 2, 3},\quad B &#x3D; {3, 4} \<br>A \cup B &#x3D; {1, 2, 3, 4} \<br>A \cap B &#x3D; {3} \<br>A - B &#x3D; {1, 2}<br>$$</p></div><div class="note info flat"><p><strong>邏輯運算例子</strong><br>$$<br>p: \text{今天下雨} \<br>q: \text{我帶傘} \<br>p \to q: \text{如果今天下雨，那我會帶傘}<br>$$</p></div><hr><p>📌 <strong>重點回顧</strong>  </p><ul><li>這篇就是離散數學的「符號翻譯機」  </li><li>不用死背推導，遇到不熟的符號就回來查  </li><li>表格內的 <strong>白話版</strong> 是專為考試前速讀設計</li></ul>]]></content>
    
    
    <summary type="html">離散數學入門的基本符號與概念速查，涵蓋邏輯、集合、數系、數論，附上簡單生活化例子，方便快速查找。</summary>
    
    
    
    <category term="研究所" scheme="https://yowdesert.github.io/categories/%E7%A0%94%E7%A9%B6%E6%89%80/"/>
    
    <category term="離散數學" scheme="https://yowdesert.github.io/categories/%E7%A0%94%E7%A9%B6%E6%89%80/%E9%9B%A2%E6%95%A3%E6%95%B8%E5%AD%B8/"/>
    
    
    <category term="離散數學" scheme="https://yowdesert.github.io/tags/%E9%9B%A2%E6%95%A3%E6%95%B8%E5%AD%B8/"/>
    
    <category term="數學" scheme="https://yowdesert.github.io/tags/%E6%95%B8%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>[PicoCTF] EVEN RSA CAN BE BROKEN??? 解題筆記</title>
    <link href="https://yowdesert.github.io/picoCTF/EVEN-RSA/"/>
    <id>https://yowdesert.github.io/picoCTF/EVEN-RSA/</id>
    <published>2025-08-11T11:15:00.000Z</published>
    <updated>2025-08-14T07:05:52.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicoCTF-EVEN-RSA-CAN-BE-BROKEN"><a href="#PicoCTF-EVEN-RSA-CAN-BE-BROKEN" class="headerlink" title="[PicoCTF] EVEN RSA CAN BE BROKEN???"></a>[PicoCTF] EVEN RSA CAN BE BROKEN???</h1><blockquote><p><strong>Category:</strong> Cryptography<br><strong>Difficulty:</strong> Easy<br><strong>Description:</strong><br>This service provides you an encrypted flag. Can you decrypt it with just N &amp; e?<br>Connect to the program with netcat:     </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc verbal-sleep.picoctf.net 51510</span><br></pre></td></tr></table></figure><p>The program’s source code can be downloaded here.</p></blockquote><hr><h2 id="題目筆記"><a href="#題目筆記" class="headerlink" title="題目筆記"></a>題目筆記</h2><ul><li>題目提供了一個 RSA 加密的環境，只給了 <strong>N</strong>、<strong>e</strong> 與加密後的密文。</li><li>一般 RSA 需要將 N 分解為兩個質數 p 和 q，才可以計算私鑰並解密。</li><li>題目的關鍵：<strong>N 是偶數</strong><br>這在正常 RSA 中是不可能的（因為 p 與 q 都是奇質數），因此可以推測 <strong>其中一個質因數是 2</strong>。</li></ul><hr><h2 id="解題步驟"><a href="#解題步驟" class="headerlink" title="解題步驟"></a>解題步驟</h2><h3 id="1-連線取得題目數據"><a href="#1-連線取得題目數據" class="headerlink" title="1. 連線取得題目數據"></a>1. 連線取得題目數據</h3><ul><li>使用題目提供的 <code>nc</code> 指令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc verbal-sleep.picoctf.net 51510</span><br></pre></td></tr></table></figure> 會得到3組數字： <details> <summary>點我展開 N, e, cyphertext</summary> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">N: 23699934164118883579301772868468610522855398699101470432464301706604093983993724690398866051915307099172198837189221549627296870046186474519602638094970754</span><br><span class="line">e: 65537</span><br><span class="line">cyphertext: 11596761688120110826821498998827014653094511592088849547225306574877488206530053305458943666206403492895885743847965127326690553567226913671355611361014981</span><br></pre></td></tr></table></figure> </details></li></ul><h3 id="2-RSA-的基本概念，可以參考我有關RSA的文章"><a href="#2-RSA-的基本概念，可以參考我有關RSA的文章" class="headerlink" title="2.RSA 的基本概念，可以參考我有關RSA的文章"></a>2.<a href="/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsRSA/">RSA 的基本概念，可以參考我有關RSA的文章</a></h3><table><thead><tr><th>名稱</th><th>說明</th></tr></thead><tbody><tr><td>公開金鑰</td><td>$(e, N)$</td></tr><tr><td>私密金鑰</td><td>$(d, N)$</td></tr><tr><td>N 的組成</td><td>$N &#x3D; p \times q$，其中 p、q 為大質數</td></tr><tr><td>加密公式</td><td>$c \equiv m^{e} \pmod{N}$</td></tr><tr><td>解密公式</td><td>$m \equiv c^{d} \pmod{N}$</td></tr><tr><td>歐拉函數 φ(N)</td><td>$\varphi(N) &#x3D; (p - 1)(q - 1)$</td></tr><tr><td>私鑰 d</td><td>$d \equiv e^{-1} \pmod{\varphi(N)}$</td></tr></tbody></table><h3 id="3-開始計算-分解N"><a href="#3-開始計算-分解N" class="headerlink" title="3.開始計算 - 分解N"></a>3.開始計算 - 分解N</h3><ul><li>從RSA的數學概念裡可以知道 N &#x3D; p * q<br>  而 p q 都是 <strong>質數</strong><br>  但 題目給的 N 是<code>偶數</code><br>  所以可以得知 p 或 q 有一個是 <code>2</code> (2是質數裡唯一的偶數)<br>  而另一個就為是 <code>N / 2</code><br>  得知 p與q 就可以解密了！</li></ul><h3 id="4-計算歐拉函數φ-N"><a href="#4-計算歐拉函數φ-N" class="headerlink" title="4. 計算歐拉函數φ(N)"></a>4. 計算歐拉函數φ(N)</h3><ul><li>RSA 中：<br>  $φ(N) &#x3D; (p-1)(q-1)$ </li><li>因為 p &#x3D; 2 :<br>  $ φ(N) &#x3D; (2−1)(q−1)&#x3D;q−1$</li></ul><h3 id="5-計算-私鑰-d"><a href="#5-計算-私鑰-d" class="headerlink" title="5.計算 私鑰 d"></a>5.計算 私鑰 <code>d</code></h3><ul><li>RSA中，<code>d</code>的公式:<br>  $d \equiv e^{-1} \pmod{\varphi(N)}$</li></ul><h3 id="6-解密密文"><a href="#6-解密密文" class="headerlink" title="6. 解密密文"></a>6. 解密密文</h3><ul><li><p>RSA中，解密公式:<br>   $m \equiv c^{d} \pmod{N}$</p></li><li><p>我們可以使用 <code>Python</code> 幫助我們解碼</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes, inverse</span><br><span class="line"></span><br><span class="line">N = <span class="number">23699934164118883579301772868468610522855398699101470432464301706604093983993724690398866051915307099172198837189221549627296870046186474519602638094970754</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">11596761688120110826821498998827014653094511592088849547225306574877488206530053305458943666206403492895885743847965127326690553567226913671355611361014981</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">2</span></span><br><span class="line">q = N // p</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, N)</span><br><span class="line"></span><br><span class="line">flag = long_to_bytes(m).decode()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="成功獲取-Flag"><a href="#成功獲取-Flag" class="headerlink" title="成功獲取 Flag"></a>成功獲取 Flag</h2><p>恭喜你拿到 Flag 了！</p><hr><h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><ul><li><p>如果 N 是偶數，RSA 幾乎可以瞬間被破解，因為其中一個質數是 2 ， 那就可以知道另一個數字是多少。</p></li><li><p>常規 RSA 中，p 和 q 都大多是大質數且為奇數。</p></li><li><p>Python 的 Crypto.Util.number 提供了 inverse 與 long_to_bytes，方便進行 RSA 解密。</p></li></ul>]]></content>
    
    
    <summary type="html">PicoCTF EVEN RSA CAN BE BROKEN??? 題目的解題過程與筆記。</summary>
    
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/categories/PicoCTF/"/>
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/categories/PicoCTF/Cryptography/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/PicoCTF/Cryptography/Easy/"/>
    
    
    <category term="Easy" scheme="https://yowdesert.github.io/tags/Easy/"/>
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/tags/Cryptography/"/>
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/tags/PicoCTF/"/>
    
  </entry>
  
  <entry>
    <title>[PicoCTF] RED 解題筆記</title>
    <link href="https://yowdesert.github.io/picoCTF/RED/"/>
    <id>https://yowdesert.github.io/picoCTF/RED/</id>
    <published>2025-08-09T14:00:00.000Z</published>
    <updated>2025-08-14T07:05:52.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicoCTF-RED"><a href="#PicoCTF-RED" class="headerlink" title="[PicoCTF] RED"></a>[PicoCTF] RED</h1><blockquote><p><strong>Category:</strong> Forensics<br><strong>Difficulty:</strong> Easy<br><strong>Description:</strong><br>RED, RED, RED, RED<br>Download the image: <code>red.png</code></p></blockquote><hr><h2 id="題目筆記"><a href="#題目筆記" class="headerlink" title="題目筆記"></a>題目筆記</h2><ul><li>題目提供一張全紅色圖片 <code>red.png</code>  </li><li>先檢查圖片的詳細資訊  </li><li>使用 <code>exiftool</code> 查看圖片的 Metadata  <blockquote><p><code>exiftool</code> 名稱來自於：<br>EXIF + Tool &#x3D; Exchangeable Image File Format Tool</p></blockquote></li><li>使用 <code>zsteg</code> 查看圖片的LSB<blockquote><p>“z” + “steg”<br>&#x3D; “z”（GPT是說沒什麼特別意義啦…如果有知道的可以留言說一下）+ steg（Steganography） 隱寫術</p></blockquote></li></ul><hr><h2 id="解題步驟"><a href="#解題步驟" class="headerlink" title="解題步驟"></a>解題步驟</h2><h3 id="1-分析圖片的Metadata"><a href="#1-分析圖片的Metadata" class="headerlink" title="1. 分析圖片的Metadata"></a>1. 分析圖片的Metadata</h3><ul><li>下載完題目給的圖片會得到一張全紅的圖片，我們可以選擇查看他的<code>詳細資料</code></li><li>我們可以使用linux指令 <code>exiftool</code> 工具解析</li><li>我們輸入指令後  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exiftool red.png</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-分析完圖片後"><a href="#2-分析完圖片後" class="headerlink" title="2. 分析完圖片後"></a>2. 分析完圖片後</h3><ul><li>我們得到這圖片的詳細資料 會發現有一欄特別奇怪  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Poem: </span><br><span class="line">    Crimson heart, </span><br><span class="line">    vibrant and bold,.</span><br><span class="line">    Hearts flutter at your sight..</span><br><span class="line">    Evenings glow softly red,.</span><br><span class="line">    Cherries burst with sweet life..</span><br><span class="line">    Kisses linger with your warmth..</span><br><span class="line">    Love deep as merlot..</span><br><span class="line">    Scarlet leaves falling softly,.</span><br><span class="line">    Bold in every stroke.</span><br></pre></td></tr></table></figure>  我們合理猜測她是藏頭詩 <code>CHECKLSB</code></li></ul><h3 id="3-查看圖片的LSB資訊"><a href="#3-查看圖片的LSB資訊" class="headerlink" title="3. 查看圖片的LSB資訊"></a>3. 查看圖片的LSB資訊</h3><ul><li>可以使用 <code>zsteg</code> 這個工具查看圖片的LSB資訊（Least Significant Bit，最低有效位元）</li><li>使用zsteg指令  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zsteg red.png</span><br></pre></td></tr></table></figure>  會得到好幾條資訊，我們可以看到一條像是Flag的資訊  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1,rgba,lsb,xy.. text: </span><br><span class="line">&quot;cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==&quot;</span><br></pre></td></tr></table></figure>  觀察發現這是一長串 <strong>Base64 編碼</strong>字串（而且重複了好幾次）。</li></ul><h3 id="4-取出並解碼-Base64"><a href="#4-取出並解碼-Base64" class="headerlink" title="4. 取出並解碼 Base64"></a>4. 取出並解碼 Base64</h3><ul><li>我們只需要解碼一個即可： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==&quot;</span> | <span class="built_in">base64</span> -d</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="成功獲取-Flag"><a href="#成功獲取-Flag" class="headerlink" title="成功獲取 Flag"></a>成功獲取 Flag</h2><p><strong>恭喜你拿到 Flag 了！</strong>  </p><hr><p>補充說明</p><ul><li>exiftool 可以檢查圖片的 Metadata</li><li>LSB（最低有效位元）隱寫是常見的圖片隱藏資料方法</li><li>zsteg 是專門針對 PNG &#x2F; BMP 格式的 LSB 分析工具</li><li>Base64 編碼在 CTF 中很常用來隱藏文字資料</li></ul>]]></content>
    
    
    <summary type="html">PicoCTF RED 題目的解題過程與筆記。</summary>
    
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/categories/PicoCTF/"/>
    
    <category term="Forensics" scheme="https://yowdesert.github.io/categories/PicoCTF/Forensics/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/PicoCTF/Forensics/Easy/"/>
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/tags/PicoCTF/"/>
    
    <category term="Forensics" scheme="https://yowdesert.github.io/tags/Forensics/"/>
    
  </entry>
  
  <entry>
    <title>[PicoCTF] Ph4nt0m 1ntrud3r 解題筆記</title>
    <link href="https://yowdesert.github.io/picoCTF/Ph4nt0m1ntrud3r/"/>
    <id>https://yowdesert.github.io/picoCTF/Ph4nt0m1ntrud3r/</id>
    <published>2025-08-09T13:30:00.000Z</published>
    <updated>2025-08-14T07:05:52.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicoCTF-Ph4nt0m-1ntrud3r"><a href="#PicoCTF-Ph4nt0m-1ntrud3r" class="headerlink" title="[PicoCTF] Ph4nt0m 1ntrud3r"></a>[PicoCTF] Ph4nt0m 1ntrud3r</h1><blockquote><p><strong>Category:</strong> Forensics<br><strong>Difficulty:</strong> Easy<br><strong>Description:</strong><br>A digital ghost has breached my defenses, and my sensitive data has been stolen! 😱💻 Your mission is to uncover how this phantom intruder infiltrated my system and retrieve the hidden flag.<br>To solve this challenge, you’ll need to analyze the provided PCAP file and track down the attack method. The attacker has cleverly concealed his moves in well timely manner. Dive into the network traffic, apply the right filters and show off your forensic prowess and unmask the digital intruder!<br>Find the PCAP file here Network Traffic PCAP file and try to get the flag.</p></blockquote><hr><h2 id="題目筆記"><a href="#題目筆記" class="headerlink" title="題目筆記"></a>題目筆記</h2><ul><li>題目提供了一份 PCAP 檔案（網路封包擷取檔案）  </li><li>需要使用 Wireshark 或 tshark 等工具打開分析  </li><li>題目提示(Tips)強調：<strong>時間（Time）非常重要</strong>，因此先依時間排序封包  </li><li>注意封包長度（Len）變化，發現部分封包長度由 8 變成 12，很可能是有用資料  </li><li>將 Len &#x3D; 12 的 TCP payload 的十六進制資料複製下來</li></ul><hr><h2 id="解題步驟"><a href="#解題步驟" class="headerlink" title="解題步驟"></a>解題步驟</h2><h3 id="1-打開-PCAP-檔案並排序封包"><a href="#1-打開-PCAP-檔案並排序封包" class="headerlink" title="1. 打開 PCAP 檔案並排序封包"></a>1. 打開 PCAP 檔案並排序封包</h3><ul><li>使用 Wireshark 打開 PCAP  </li><li>依時間（Time）欄排序，觀察封包流動</li></ul><h3 id="2-找出-Len-12-的-TCP-payload"><a href="#2-找出-Len-12-的-TCP-payload" class="headerlink" title="2. 找出 Len &#x3D; 12 的 TCP payload"></a>2. 找出 Len &#x3D; 12 的 TCP payload</h3><ul><li>篩選出 TCP payload 長度為 12 的封包  </li><li>複製所有此類封包的十六進制 Payload，得到多組 Hex 編碼：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">63476c6a62304e5552673d3d</span><br><span class="line">657a46305833633063773d3d</span><br><span class="line">626e52666447673064413d3d</span><br><span class="line">587a4d3063336c6664413d3d</span><br><span class="line">596d68664e484a664d673d3d</span><br><span class="line">5a54466d5a6a41324d773d3d</span><br><span class="line">66513d3d</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-轉換-Hex-到-ASCII-字串"><a href="#3-轉換-Hex-到-ASCII-字串" class="headerlink" title="3. 轉換 Hex 到 ASCII 字串"></a>3. 轉換 Hex 到 ASCII 字串</h3><ul><li><p>將上面 Hex 解碼為 ASCII，得到一串 Base64 字串：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cGljb0NURg==</span><br><span class="line">ezF0X3c0cw==</span><br><span class="line">bnRfdGg0dA==</span><br><span class="line">XzM0c3lfdA==</span><br><span class="line">YmhfNHJfMg==</span><br><span class="line">ZTFmZjA2Mw==</span><br><span class="line">fQ==</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-對-Base64-進行解碼"><a href="#4-對-Base64-進行解碼" class="headerlink" title="4. 對 Base64 進行解碼"></a>4. 對 Base64 進行解碼</h3><ul><li>將上述的 Base64 進一步解碼，就會得到答案了！<br>有關各種編碼方式歡迎查看這篇文章 : <a href="/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E5%B8%B8%E8%A6%8B%E7%B7%A8%E7%A2%BC%E6%96%B9%E5%BC%8F%E4%B8%80%E8%A6%BD/">常見編碼方式一覽</a></li></ul><hr><h2 id="成功獲取-Flag"><a href="#成功獲取-Flag" class="headerlink" title="成功獲取 Flag"></a>成功獲取 Flag</h2><p>恭喜你拿到 Flag 了！<br><code>picoCTF&#123;1t_w4snt_th4t_34sy_tbh_4r_2e1ff063&#125;</code></p><hr><h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><ul><li>PCAP 是用來記錄網路封包的格式  </li><li>Wireshark 是分析網路封包的工具</li><li>時間排序和封包長度是關鍵的線索  </li><li>Base64 編碼與解碼是常見資料隱藏技術</li></ul>]]></content>
    
    
    <summary type="html">PicoCTF Ph4nt0m 1ntrud3r 題目的解題過程與筆記。</summary>
    
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/categories/PicoCTF/"/>
    
    <category term="Forensics" scheme="https://yowdesert.github.io/categories/PicoCTF/Forensics/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/PicoCTF/Forensics/Easy/"/>
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/tags/PicoCTF/"/>
    
    <category term="Forensics" scheme="https://yowdesert.github.io/tags/Forensics/"/>
    
  </entry>
  
  <entry>
    <title>[PicoCTF] Verify 解題筆記</title>
    <link href="https://yowdesert.github.io/posts/b7f15b2a.html"/>
    <id>https://yowdesert.github.io/posts/b7f15b2a.html</id>
    <published>2025-08-09T13:20:00.000Z</published>
    <updated>2025-08-14T07:05:52.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicoCTF-Verify"><a href="#PicoCTF-Verify" class="headerlink" title="[PicoCTF] Verify"></a>[PicoCTF] Verify</h1><blockquote><p><strong>Category:</strong> Forensics<br><strong>Difficulty:</strong> Easy<br><strong>Description:</strong><br>People keep trying to trick my players with imitation flags.<br>I want to make sure they get the real thing!<br>I’m going to provide the <strong>SHA-256 hash</strong> and a decrypt script to help you know that my flags are legitimate.<br>額外細節會在啟動挑戰實例後提供。</p></blockquote><hr><h2 id="題目筆記"><a href="#題目筆記" class="headerlink" title="題目筆記"></a>題目筆記</h2><p>這題主要觀念在於 <strong>SHA-256 雜湊值比對</strong> 與 <strong>Linux 基本檔案操作</strong>。<br>題目會給你：</p><ol><li>一個檔案的 SHA-256 雜湊值  </li><li>一個解密腳本 <code>decrypt.sh</code>  </li><li>一個目錄 <code>files</code> 裡面放了很多檔案</li></ol><p>我們需要找到與題目提供的雜湊值相符的檔案，再用 <code>decrypt.sh</code> 解密。</p><hr><h2 id="解題步驟"><a href="#解題步驟" class="headerlink" title="解題步驟"></a>解題步驟</h2><h3 id="1-連上主機"><a href="#1-連上主機" class="headerlink" title="1. 連上主機"></a>1. 連上主機</h3><p>根據題目給的 <strong>連線資訊與密碼</strong>，用 SSH 登入伺服器：</p><h3 id="2-查看目錄內容"><a href="#2-查看目錄內容" class="headerlink" title="2. 查看目錄內容"></a>2. 查看目錄內容</h3><ul><li>登入後用ls指令，先看看有哪些檔案： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li>會看到<code>2個檔案</code>以及<code>1個資料夾</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksum.txt  decrypt.sh  files</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-計算-SHA-256"><a href="#3-計算-SHA-256" class="headerlink" title="3. 計算 SHA-256"></a>3. 計算 SHA-256</h3><ul><li>使用 <code>sha256sum</code> 計算 files 資料夾內所有檔案的 <code>SHA-256 雜湊值</code>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sha256sum</span> files/*</span><br></pre></td></tr></table></figure></li><li>將files裡面所有的檔案轉成 SHA-256 的 Hash_Code<br> 輸出會類似： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">03b52eabed517324828b9e09cbbf8a7b0911f348f76cf989ba6d51acede6d5d8  files/file1</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-尋找目標雜湊值"><a href="#4-尋找目標雜湊值" class="headerlink" title="4.尋找目標雜湊值"></a>4.尋找目標雜湊值</h3><ul><li>假設題目提供的雜湊值為： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03b52eabed517324828b9e09cbbf8a7b0911f348f76cf989ba6d51acede6d5d8</span><br></pre></td></tr></table></figure></li><li>我們可以用 <code>grep</code> 快速比對： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sha256sum</span> files/* | grep 03b52eabed517324828b9e09cbbf8a7b0911f348f76cf989ba6d51acede6d5d8</span><br></pre></td></tr></table></figure> 這樣就能找到正確的檔案名稱，例如：<br> <code>files/flag1</code></li></ul><h3 id="5-解密檔案"><a href="#5-解密檔案" class="headerlink" title="5.解密檔案"></a>5.解密檔案</h3><ul><li>用檔案內提供的 decrypt.sh 解密檔案： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./decrypt.sh files/flag1</span><br></pre></td></tr></table></figure> 如果檔案沒有執行權限，要先取得權限： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x decrypt.sh</span><br></pre></td></tr></table></figure> <strong style="font-size:24px;"> <strong>執行後就能拿到Flag了</strong> </strong></li></ul><hr><h2 id="成功獲取-Flag"><a href="#成功獲取-Flag" class="headerlink" title="成功獲取 Flag"></a>成功獲取 Flag</h2><p><strong>恭喜你拿到 Flag 了！</strong>  </p><hr><h2 id="補充筆記"><a href="#補充筆記" class="headerlink" title="補充筆記"></a>補充筆記</h2><h3 id="SHA-256-是什麼？"><a href="#SHA-256-是什麼？" class="headerlink" title="SHA-256 是什麼？"></a>SHA-256 是什麼？</h3><p><strong>SHA-256</strong> 是一種<strong>不可逆的雜湊函數（Hash Function）</strong>，<br>它會將任意長度的輸入轉換成固定長度的<strong>256-bit</strong>（即64字元的十六進制字串）輸出。</p><p>SHA-256 常用於：</p><ul><li>檔案完整性驗證</li><li>密碼存儲</li></ul><h3 id="為什麼要比對雜湊值？"><a href="#為什麼要比對雜湊值？" class="headerlink" title="為什麼要比對雜湊值？"></a>為什麼要比對雜湊值？</h3><ul><li>如果檔案被修改，即使只改一個字元，SHA-256 的結果也會完全不同。</li><li>因此，可以用來驗證檔案是否被篡改，確保資料完整性。</li></ul>]]></content>
    
    
    <summary type="html">PicoCTF Verify 題目的解題過程與筆記。</summary>
    
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/categories/PicoCTF/"/>
    
    <category term="Forensics" scheme="https://yowdesert.github.io/categories/PicoCTF/Forensics/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/PicoCTF/Forensics/Easy/"/>
    
    
    <category term="Easy" scheme="https://yowdesert.github.io/tags/Easy/"/>
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/tags/Cryptography/"/>
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/tags/PicoCTF/"/>
    
    <category term="Forensics" scheme="https://yowdesert.github.io/tags/Forensics/"/>
    
  </entry>
  
  <entry>
    <title>[資訊安全] 常見編碼方式一覽</title>
    <link href="https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E5%B8%B8%E8%A6%8B%E7%B7%A8%E7%A2%BC%E6%96%B9%E5%BC%8F%E4%B8%80%E8%A6%BD/"/>
    <id>https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E5%B8%B8%E8%A6%8B%E7%B7%A8%E7%A2%BC%E6%96%B9%E5%BC%8F%E4%B8%80%E8%A6%BD/</id>
    <published>2025-08-08T13:00:00.000Z</published>
    <updated>2025-08-14T04:57:29.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇整理了我在練習 picoCTF 或資訊安全題目中常見的編碼方式與判斷技巧，搭配 GPT 一起整理的重點。<br>如果有遺漏或錯誤歡迎在下方留言討論！</p></blockquote><hr><h2 id="📋-編碼類型總覽"><a href="#📋-編碼類型總覽" class="headerlink" title="📋 編碼類型總覽"></a>📋 編碼類型總覽</h2><table><thead><tr><th>類型</th><th>範例</th><th>特徵</th><th>常見用途</th></tr></thead><tbody><tr><td><strong>Base64</strong></td><td><code>cGljb0NURntzZWNyZXR9</code></td><td>僅包含 <code>A–Z</code>, <code>a–z</code>, <code>0–9</code>, <code>+</code>, <code>/</code>，結尾可能有 <code>=</code></td><td>傳輸二進位資料、Email 附件、JWT</td></tr><tr><td><strong>URL Encoding</strong></td><td><code>picoCTF%7Burl_3nc0ded%7D</code></td><td><code>%xx</code> 表示特殊字元，如 <code>%20</code> 空格、<code>%3D</code> 等號</td><td>網址參數處理、表單資料轉碼</td></tr><tr><td><strong>Hexadecimal (十六進位)</strong></td><td><code>7069636f4354467b7d</code></td><td>僅含 <code>0–9</code>, <code>a–f</code>，每兩位對應一個 byte</td><td>Shellcode、封包分析、低階除錯</td></tr><tr><td><strong>HTML Entity</strong></td><td><code>&amp;lt;script&amp;gt;</code></td><td><code>&amp;xxx;</code> 或 <code>&amp;#xNN;</code> 表示特殊字元</td><td>避免 XSS、HTML 轉義</td></tr><tr><td><strong>Binary (二進位)</strong></td><td><code>01110000 01101001</code></td><td>僅由 <code>0</code> 與 <code>1</code> 組成，8 位為一組</td><td>位元操作、底層教學</td></tr><tr><td><strong>Octal (八進位)</strong></td><td><code>\123\145\143</code></td><td><code>\</code> 開頭接 3 位八進位數</td><td>舊 C 字串、低層編碼</td></tr><tr><td><strong>ROT13</strong></td><td><code>cvpbPGS&#123;arkg_gbb_onq&#125;</code></td><td>字母位移 13 位，對稱編碼</td><td>淺層混淆、惡搞用途</td></tr><tr><td><strong>Morse Code</strong></td><td><code>.--. .. -.-. --- -.-. - ..-.</code></td><td>由 <code>.</code> 與 <code>-</code> 組成</td><td>CTF 常見陷阱、通訊歷史</td></tr><tr><td><strong>Base32 &#x2F; Base58 &#x2F; Base85</strong></td><td><code>MZXW6YTBOI======</code></td><td>字元集不同於 Base64</td><td>QR Code、加密貨幣地址、PDF</td></tr><tr><td><strong>Unicode Escape</strong></td><td><code>\u0070\u0069\u0063\u006f</code></td><td><code>\uXXXX</code> 格式表示 Unicode 字元</td><td>多語系處理、JSON</td></tr></tbody></table><div class="note info flat"><p>Base64 的結尾 <code>=</code> 是用來填充至長度為 4 的倍數，不是所有 Base64 都會出現 <code>=</code>，需視原始資料長度決定。</p></div><hr><h2 id="如何判斷是哪種編碼？"><a href="#如何判斷是哪種編碼？" class="headerlink" title="如何判斷是哪種編碼？"></a>如何判斷是哪種編碼？</h2><h3 id="內容特徵對照"><a href="#內容特徵對照" class="headerlink" title="內容特徵對照"></a>內容特徵對照</h3><table><thead><tr><th>特徵</th><th>推測編碼</th></tr></thead><tbody><tr><td>出現 <code>%20</code>, <code>%3D</code></td><td>URL Encoding</td></tr><tr><td>出現 <code>&amp;lt;</code>, <code>&amp;gt;</code></td><td>HTML Entity</td></tr><tr><td>只含 <code>0</code> 和 <code>1</code>，8 位為一組</td><td>Binary</td></tr><tr><td>全為十六進位且偶數長度</td><td>Hexadecimal</td></tr><tr><td>出現 <code>=</code>, 看起來亂碼但有規則</td><td>Base64</td></tr><tr><td>看起來像英文但不通順</td><td>ROT13 或 Caesar Cipher</td></tr><tr><td>有 <code>\uXXXX</code> 字元</td><td>Unicode Escape</td></tr><tr><td>只包含 <code>+-&gt;&lt;[].,</code></td><td>Brainfuck（惡搞語言）</td></tr></tbody></table><hr><h2 id="常見工具推薦"><a href="#常見工具推薦" class="headerlink" title="常見工具推薦"></a>常見工具推薦</h2><h3 id="線上工具"><a href="#線上工具" class="headerlink" title="線上工具"></a>線上工具</h3><ul><li><a href="https://gchq.github.io/CyberChef/">CyberChef</a></li><li><a href="https://www.dcode.fr/">Dcode.fr</a></li><li><a href="https://www.base64decode.org/">Base64 Decode</a></li></ul><h3 id="Linux-macOS-常用指令"><a href="#Linux-macOS-常用指令" class="headerlink" title="Linux &#x2F; macOS 常用指令"></a>Linux &#x2F; macOS 常用指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;cGljbw==&#x27;</span> | <span class="built_in">base64</span> -d         <span class="comment"># Base64 解碼</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;7069636f&#x27;</span> | xxd -r -p      <span class="comment"># Hex 解碼</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;\123\145\143&#x27;</span>              <span class="comment"># Octal 解碼</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\u0070\u0069\u0063\u006f&quot;</span>   <span class="comment"># Unicode Escape</span></span><br></pre></td></tr></table></figure><h3 id="Python-編碼-解碼範例"><a href="#Python-編碼-解碼範例" class="headerlink" title="Python 編碼&#x2F;解碼範例"></a>Python 編碼&#x2F;解碼範例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64, urllib.parse, codecs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base64 解碼</span></span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">&quot;cGljbw==&quot;</span>).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 解碼</span></span><br><span class="line"><span class="built_in">print</span>(urllib.parse.unquote(<span class="string">&quot;%70%69%63%6f&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROT13 解碼</span></span><br><span class="line"><span class="built_in">print</span>(codecs.decode(<span class="string">&quot;cvpbPGS&#123;arkg_gbb_onq&#125;&quot;</span>, <span class="string">&quot;rot_13&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hex 解碼</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(<span class="string">&quot;7069636f&quot;</span>).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unicode Escape</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\u0070\u0069\u0063\u006f&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>工具推薦 CyberChef，一頁搞定多種解碼流程。<br>遇到不熟悉的編碼也可以用 猜→測試→驗證→Google 的方式查出線索！<br>或是詢問最近進化的GPT5好夥伴也可以歐！！！</p><p><em><strong>如果有其他冷門編碼想補充（如：Base91、UUEncode、xxEncode），也歡迎留言交流 🙌</strong></em></p>]]></content>
    
    
    <summary type="html">一覽 Base64、URL Encoding、Hex、ROT13 等常見編碼方式與判斷技巧</summary>
    
    
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
    <category term="編碼" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E7%B7%A8%E7%A2%BC/"/>
    
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
    <category term="編碼" scheme="https://yowdesert.github.io/tags/%E7%B7%A8%E7%A2%BC/"/>
    
  </entry>
  
  <entry>
    <title>[資訊安全] AES 是什麼？快速理解筆記</title>
    <link href="https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsAES/"/>
    <id>https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsAES/</id>
    <published>2025-08-07T09:00:00.000Z</published>
    <updated>2025-08-14T04:35:56.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Topic-AES-是什麼？"><a href="#Topic-AES-是什麼？" class="headerlink" title="Topic : AES 是什麼？"></a>Topic : AES 是什麼？</h1><h2 id="AES-是一種-對稱加密演算法"><a href="#AES-是一種-對稱加密演算法" class="headerlink" title="AES 是一種 對稱加密演算法"></a>AES 是一種 對稱加密演算法</h2><h3 id="一、什麼是對稱加密？"><a href="#一、什麼是對稱加密？" class="headerlink" title="一、什麼是對稱加密？"></a>一、什麼是對稱加密？</h3><ul><li>對稱加密只使用「一把金鑰」：  <ul><li>加密與解密 <strong>都使用相同金鑰</strong></li></ul></li><li>對稱加密是指「加密與解密使用相同金鑰」的加密方式，也稱為單鑰加密。</li><li>常見用途：加密檔案、訊息、VPN 傳輸等</li></ul><blockquote><p>✅ 優點：速度快，適合大量資料加密<br>❌ 缺點：金鑰分發不安全（需先共享）</p></blockquote><hr><h2 id="二、AES-與非對稱加密比較"><a href="#二、AES-與非對稱加密比較" class="headerlink" title="二、AES 與非對稱加密比較"></a>二、AES 與非對稱加密比較</h2><table><thead><tr><th>比較項目</th><th>對稱加密（AES）</th><th>非對稱加密（RSA）</th></tr></thead><tbody><tr><td>金鑰數量</td><td>1 把</td><td>2 把（公+私）</td></tr><tr><td>加解密速度</td><td>快</td><td>慢</td></tr><tr><td>加密大量資料</td><td>適合</td><td>不適合</td></tr><tr><td>金鑰交換難度</td><td>高（要先傳）</td><td>低（公鑰可公開）</td></tr><tr><td>支援簽章驗證</td><td>否</td><td>是</td></tr><tr><td>常見用途</td><td>檔案加密、VPN</td><td>傳輸金鑰、簽章驗證</td></tr></tbody></table><hr><h2 id="三、AES-的運作原理"><a href="#三、AES-的運作原理" class="headerlink" title="三、AES 的運作原理"></a>三、AES 的運作原理</h2><h3 id="AES（Advanced-Encryption-Standard）"><a href="#AES（Advanced-Encryption-Standard）" class="headerlink" title="AES（Advanced Encryption Standard）"></a>AES（Advanced Encryption Standard）</h3><p>是一種<strong>區塊加密演算法</strong>，特點：</p><ul><li><strong>固定區塊大小：128 bits</strong></li><li>每次加密處理 128 位元（16 bytes）資料區塊，區塊大小固定為 128 bits（不隨金鑰長度改變）。</li><li>支援金鑰長度：128、192、256 bits</li><li>經過多輪（rounds）加密處理  </li><li>128-bit 金鑰 → 10 輪  (AES-128)</li><li>192-bit 金鑰 → 12 輪  (AES-192)</li><li>256-bit 金鑰 → 14 輪  (AES-256)</li></ul><hr><h3 id="四、AES-加密流程（簡化版）"><a href="#四、AES-加密流程（簡化版）" class="headerlink" title="四、AES 加密流程（簡化版）"></a>四、AES 加密流程（簡化版）</h3><p>每輪會做以下操作（簡化說明）：</p><p>每輪（round）包含以下步驟（簡化說明）：</p><p>1.<strong>SubBytes</strong>：使用 S-box 對每個 byte 進行非線性轉換，增加混淆性（Confusion）</p><p>2.<strong>ShiftRows</strong>：將 state 中的每一列進行循環左移，增加擴散性（Diffusion）</p><p>3.<strong>MixColumns</strong>：在 GF(2^8) 上對每一欄進行多項式混合運算，提高擴散性</p><p>4.<strong>AddRoundKey</strong>：將 state 與對應的輪金鑰做 XOR</p><p>🔹 最後一輪會略過 MixColumns步驟</p><hr><h2 id="五、AES-加密模式（Modes-of-Operation）"><a href="#五、AES-加密模式（Modes-of-Operation）" class="headerlink" title="五、AES 加密模式（Modes of Operation）"></a>五、AES 加密模式（Modes of Operation）</h2><p>加密區塊資料常會搭配「模式」來使用：</p><table><thead><tr><th>模式名稱</th><th>特性</th><th>備註</th></tr></thead><tbody><tr><td>ECB</td><td>每個區塊獨立加密</td><td>❌ 不安全，可能洩漏資料結構</td></tr><tr><td>CBC</td><td>加密每區塊前會與上一區塊做 XOR</td><td>✅ 較常用</td></tr><tr><td>CFB &#x2F; OFB</td><td>適合串流加密</td><td>✅ 可處理非整數倍資料</td></tr><tr><td>GCM</td><td>提供驗證功能</td><td>✅ 同時加密與驗證完整性</td></tr></tbody></table><hr><h2 id="六、AES-的安全性來自？"><a href="#六、AES-的安全性來自？" class="headerlink" title="六、AES 的安全性來自？"></a>六、AES 的安全性來自？</h2><ul><li><p>AES 基於 <strong>替代與轉換（Substitution + Permutation）</strong> 概念</p></li><li><p>到目前為止：</p><ul><li>未有有效的破解方式</li><li>被廣泛認為是安全的加密標準</li><li>美國政府與多數企業皆採用 AES</li></ul></li><li><p>AES-128、AES-192、AES-256 的安全性皆非常高，但 AES-256 提供更高強度的防禦力，常用於軍事、政府機構等領域。<br>✅ 只要金鑰沒外洩，AES 就非常可靠</p></li></ul><hr><h2 id="七、混合加密應用場景"><a href="#七、混合加密應用場景" class="headerlink" title="七、混合加密應用場景"></a>七、混合加密應用場景</h2><p>實務上，常會搭配 RSA 使用：</p><blockquote><p>✅ 用 RSA 傳送 AES 金鑰，再用 AES 加密大量資料</p></blockquote><p>這樣就兼具「速度」與「金鑰安全性」：</p><ol><li>伺服器產生 AES 金鑰  </li><li>用 RSA 公鑰加密 AES 金鑰  </li><li>傳送給對方，開始用 AES 通訊</li></ol><hr><h3 id="八、總結"><a href="#八、總結" class="headerlink" title="八、總結"></a>八、總結</h3><table><thead><tr><th>項目</th><th>說明</th></tr></thead><tbody><tr><td>加密類型</td><td>對稱式加密</td></tr><tr><td>金鑰數量</td><td>1 把</td></tr><tr><td>金鑰長度</td><td>常見為 128、192、256 bits</td></tr><tr><td>加密速度</td><td>快，適合大量資料</td></tr><tr><td>常見用途</td><td>資料加密、VPN、儲存檔案等</td></tr><tr><td>安全基礎</td><td>S-box 與多輪混淆與擴散</td></tr></tbody></table><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Topic-AES-是什麼？&quot;&gt;&lt;a href=&quot;#Topic-AES-是什麼？&quot; class=&quot;headerlink&quot; title=&quot;Topic : AES 是什麼？&quot;&gt;&lt;/a&gt;Topic : AES 是什麼？&lt;/h1&gt;&lt;h2 id=&quot;AES-是一種-對稱加密演</summary>
      
    
    
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/Cryptography/"/>
    
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/tags/Cryptography/"/>
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
    <category term="AES" scheme="https://yowdesert.github.io/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>[資訊安全] 對稱式加密 vs 非對稱式加密 (RSA)</title>
    <link href="https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86vs%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86/"/>
    <id>https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86vs%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86/</id>
    <published>2025-08-07T08:30:00.000Z</published>
    <updated>2025-08-14T07:05:52.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Topic-對稱式加密-vs-非對稱式加密"><a href="#Topic-對稱式加密-vs-非對稱式加密" class="headerlink" title="Topic: 對稱式加密 vs 非對稱式加密"></a>Topic: 對稱式加密 vs 非對稱式加密</h1><hr><h2 id="一、什麼是-RSA？"><a href="#一、什麼是-RSA？" class="headerlink" title="一、什麼是 RSA？"></a>一、<a href="/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsRSA/">什麼是 RSA？</a></h2><ul><li><p>RSA 是一種「非對稱加密演算法」，由 Rivest、Shamir、Adleman 發明，透過一對金鑰（公鑰 + 私鑰）來加解密資料。</p></li><li><p>✅ 公鑰可以公開給所有人使用來加密資料  </p></li><li><p>✅ 私鑰只能自己保留，用來解密資料  </p></li><li><p>✅ 也可以用私鑰進行簽章，讓別人用公鑰驗證</p></li></ul><hr><h2 id="二、金鑰數量差異"><a href="#二、金鑰數量差異" class="headerlink" title="二、金鑰數量差異"></a>二、金鑰數量差異</h2><table><thead><tr><th>加密類型</th><th>使用幾把金鑰？</th><th>說明</th></tr></thead><tbody><tr><td>🔐 對稱加密</td><td>1 把金鑰</td><td>加密與解密都用同一把金鑰</td></tr><tr><td>🔓 非對稱加密 (RSA)</td><td>2 把金鑰（公鑰 + 私鑰）</td><td>加密用公鑰，解密用私鑰（簽章則相反）</td></tr></tbody></table><hr><h2 id="三、適合用途不同"><a href="#三、適合用途不同" class="headerlink" title="三、適合用途不同"></a>三、適合用途不同</h2><table><thead><tr><th>項目</th><th>對稱加密</th><th>非對稱加密（RSA）</th></tr></thead><tbody><tr><td>🔒 資料加密</td><td>✅ 適合大量資料加密</td><td>❌ 速度慢，不適合大資料</td></tr><tr><td>🔐 金鑰交換</td><td>❌ 不安全</td><td>✅ 安全，無需事先共享</td></tr><tr><td>📝 數位簽章</td><td>❌ 不支援</td><td>✅ 支援，驗證身份與完整性</td></tr></tbody></table><hr><h2 id="四、速度與效能差異"><a href="#四、速度與效能差異" class="headerlink" title="四、速度與效能差異"></a>四、速度與效能差異</h2><ul><li><p>對稱加密（如 <strong>AES</strong>）：<br>✅ <strong>速度快</strong>，適合加密整份檔案或大量資料。</p></li><li><p>非對稱加密（如 <strong>RSA</strong>）：<br>❌ <strong>速度慢</strong>，多用來保護小型資料（如金鑰）。</p></li></ul><p>📌 <strong>實務應用：混合加密（Hybrid Encryption）</strong></p><blockquote><p>使用 RSA 加密一把 AES 金鑰，再使用 AES 加密實際資料。<br>✔️ 兼具效能與安全性。</p></blockquote><hr><h2 id="五、密鑰分發安全性"><a href="#五、密鑰分發安全性" class="headerlink" title="五、密鑰分發安全性"></a>五、密鑰分發安全性</h2><table><thead><tr><th>項目</th><th>對稱加密</th><th>非對稱加密 (RSA)</th></tr></thead><tbody><tr><td>密鑰如何傳送？</td><td>需使用安全通道傳送</td><td>公鑰可公開，無需保密</td></tr><tr><td>是否容易被竊聽或搞錯</td><td>✅ 是</td><td>❌ 否</td></tr></tbody></table><hr><h2 id="六、安全性來源"><a href="#六、安全性來源" class="headerlink" title="六、安全性來源"></a>六、安全性來源</h2><ul><li><strong>對稱加密：</strong> 安全性來自金鑰不被竊取。</li><li><strong>非對稱加密（RSA）：</strong> 安全性基於：<ul><li>大數質因數分解困難</li><li>尚無有效演算法能從公鑰推出私鑰（傳統電腦）</li></ul></li></ul><p>⚠️ 注意：若未來量子電腦普及，RSA 可能失效。</p><hr><h2 id="✅-七、總結對照表"><a href="#✅-七、總結對照表" class="headerlink" title="✅ 七、總結對照表"></a>✅ 七、總結對照表</h2><table><thead><tr><th>比較項目</th><th>對稱加密</th><th>非對稱加密（RSA）</th></tr></thead><tbody><tr><td>金鑰數量</td><td>1 把</td><td>2 把（公鑰 + 私鑰）</td></tr><tr><td>加解密速度</td><td>✅ 快</td><td>❌ 慢</td></tr><tr><td>適合大量資料加密</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>金鑰傳遞安全性</td><td>❌ 不安全</td><td>✅ 安全</td></tr><tr><td>支援數位簽章</td><td>❌ 不支援</td><td>✅ 支援</td></tr><tr><td>常見用途</td><td>檔案加密、VPN</td><td>數位簽章、HTTPS 金鑰交換</td></tr></tbody></table><hr><p>🎉 <strong>到此你已掌握對稱與非對稱加密的核心差異！</strong></p><p><strong>如果想要更細部的快速了解歡迎查看我的另兩篇文章歐！！！</strong></p><ul><li><a href="/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsRSA/">RSA是什麼 ?</a></li><li><a href="/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsAES/">AES是什麼 ?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Topic-對稱式加密-vs-非對稱式加密&quot;&gt;&lt;a href=&quot;#Topic-對稱式加密-vs-非對稱式加密&quot; class=&quot;headerlink&quot; title=&quot;Topic: 對稱式加密 vs 非對稱式加密&quot;&gt;&lt;/a&gt;Topic: 對稱式加密 vs 非對稱式加密</summary>
      
    
    
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/Cryptography/"/>
    
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/tags/Cryptography/"/>
    
    <category term="RSA" scheme="https://yowdesert.github.io/tags/RSA/"/>
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>[資訊安全] RSA 是什麼？快速理解筆記</title>
    <link href="https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsRSA/"/>
    <id>https://yowdesert.github.io/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/WhatIsRSA/</id>
    <published>2025-08-07T08:00:00.000Z</published>
    <updated>2025-08-14T04:57:38.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Topic-RSA-是什麼？"><a href="#Topic-RSA-是什麼？" class="headerlink" title="Topic : RSA 是什麼？"></a>Topic : RSA 是什麼？</h1><h2 id="RSA-是一種-非對稱加密演算法"><a href="#RSA-是一種-非對稱加密演算法" class="headerlink" title="RSA 是一種 非對稱加密演算法"></a>RSA 是一種 非對稱加密演算法</h2><h3 id="一、什麼是非對稱加密？"><a href="#一、什麼是非對稱加密？" class="headerlink" title="一、什麼是非對稱加密？"></a>一、什麼是非對稱加密？</h3><ul><li>非對稱加密使用「一對金鑰」：<ul><li>🔓 公開金鑰（Public Key）：可以提供給他人用來加密資料</li><li>🔐 私密金鑰（Private Key）：僅自己持有，用於解密資料</li></ul></li><li>相較於對稱加密（只有一把金鑰），非對稱加密像 RSA 可以：<blockquote><p>✅ 讓「別人加密給你」，但只有你能解開</p></blockquote></li></ul><hr><h2 id="二、RSA-與對稱加密比較"><a href="#二、RSA-與對稱加密比較" class="headerlink" title="二、RSA 與對稱加密比較"></a>二、RSA 與對稱加密比較</h2><table><thead><tr><th>比較項目</th><th>對稱加密</th><th>非對稱加密（RSA）</th></tr></thead><tbody><tr><td>🔑 金鑰數量</td><td>1 把</td><td>2 把（公+私）</td></tr><tr><td>⚡ 加解密速度</td><td>快</td><td>慢</td></tr><tr><td>📦 加密大量資料</td><td>適合</td><td>不適合</td></tr><tr><td>🔁 金鑰交換難度</td><td>高（要先傳）</td><td>低（公鑰可公開）</td></tr><tr><td>🔏 支援簽章驗證</td><td>否</td><td>是</td></tr><tr><td>🔧 常見用途</td><td>檔案加密、VPN</td><td>傳輸金鑰、身份驗證、簽章</td></tr></tbody></table><hr><h2 id="三、RSA-的核心數學概念"><a href="#三、RSA-的核心數學概念" class="headerlink" title="三、RSA 的核心數學概念"></a>三、RSA 的核心數學概念</h2><h3 id="RSA-建立在一個重要的數學困難上："><a href="#RSA-建立在一個重要的數學困難上：" class="headerlink" title="RSA 建立在一個重要的數學困難上："></a>RSA 建立在一個重要的數學困難上：</h3><blockquote><p><strong>大數質因數分解很難</strong></p></blockquote><ol><li>選兩個大質數：<code>p</code> 和 <code>q</code>  </li><li>計算    $N &#x3D; p × q$（模數）  </li><li>計算歐拉函數：$φ(N) &#x3D; (p-1)(q-1)$  </li><li>選一個加密指數 <code>e</code>（常見為 <code>65537</code>）  </li><li>計算私鑰 <code>d</code>，使得：$e × d ≡ (1)mod  (N)$（d 是 e 的模反元素）</li><li>結果：</li></ol><ul><li>公開金鑰：(e, N)</li><li>私密金鑰：(d, N)</li></ul><hr><h2 id="四、RSA-加解密流程"><a href="#四、RSA-加解密流程" class="headerlink" title="四、RSA 加解密流程"></a>四、RSA 加解密流程</h2><ul><li><p>🔐 加密（使用公開金鑰）：<br> 假設你想加密明文 m（要先轉成整數），那就算：<br> $ c &#x3D; m^e mod N$<br> m 是明文（轉成整數後）</p></li><li><p>🔓 解密（使用私密金鑰）：<br> $ m &#x3D; c^d mod N$</p></li></ul><p>✅ 只有擁有私鑰的那個人能成功解密！</p><hr><h3 id="五、應用場景"><a href="#五、應用場景" class="headerlink" title="五、應用場景"></a>五、應用場景</h3><ul><li>✅ 加密敏感資料（像 HTTPS 傳輸）<br> -✅ 數位簽章（驗證訊息是否真的是某人發的）</li><li>✅ 金鑰交換（混合式加密中，先用 RSA 傳送對稱加密金鑰）</li></ul><hr><h3 id="六、RSA-的安全性來自"><a href="#六、RSA-的安全性來自" class="headerlink" title="六、RSA 的安全性來自?"></a>六、RSA 的安全性來自?</h3><ul><li>它的安全性來自於：<br> 目前沒有有效的方式在合理時間內把一個很大的 N 拆解為 p 和 q。<br> 如果有人能快速分解大數，RSA 就不安全了（例如量子電腦未來可能威脅 RSA）。</li></ul><hr><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><table><thead><tr><th>項目</th><th>說明</th></tr></thead><tbody><tr><td>金鑰種類</td><td>非對稱（公開+私密）</td></tr><tr><td>安全基礎</td><td>大數質因數分解困難</td></tr><tr><td>常用用途</td><td>加密、簽章、金鑰交換</td></tr><tr><td>常見公開指數</td><td>65537</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Topic-RSA-是什麼？&quot;&gt;&lt;a href=&quot;#Topic-RSA-是什麼？&quot; class=&quot;headerlink&quot; title=&quot;Topic : RSA 是什麼？&quot;&gt;&lt;/a&gt;Topic : RSA 是什麼？&lt;/h1&gt;&lt;h2 id=&quot;RSA-是一種-非對稱加密</summary>
      
    
    
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/categories/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/Cryptography/"/>
    
    
    <category term="Cryptography" scheme="https://yowdesert.github.io/tags/Cryptography/"/>
    
    <category term="RSA" scheme="https://yowdesert.github.io/tags/RSA/"/>
    
    <category term="資訊安全" scheme="https://yowdesert.github.io/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>[PicoCTF] head-dump 解題筆記</title>
    <link href="https://yowdesert.github.io/posts/da80d575.html"/>
    <id>https://yowdesert.github.io/posts/da80d575.html</id>
    <published>2025-08-07T06:00:00.000Z</published>
    <updated>2025-08-14T07:05:52.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Challenge-head-dump"><a href="#Challenge-head-dump" class="headerlink" title="Challenge: head-dump"></a>Challenge: head-dump</h1><blockquote><p><strong>Category:</strong> Web Exploitation<br><strong>Difficulty:</strong> Easy<br><strong>Description:</strong><br>Welcome to the challenge! In this challenge, you will explore a web application and find an endpoint that exposes a file containing a hidden flag.<br>The application is a simple blog website where you can read articles about various topics, including an article about API Documentation. Your goal is to explore the application and find the endpoint that generates files holding the server’s memory, where a secret flag is hidden.</p></blockquote><hr><h2 id="解題思路整理"><a href="#解題思路整理" class="headerlink" title="解題思路整理"></a>解題思路整理</h2><h3 id="Step-1-分析題目內容"><a href="#Step-1-分析題目內容" class="headerlink" title="Step 1: 分析題目內容"></a>Step 1: 分析題目內容</h3><p>從描述中提到：</p><blockquote><p>The application is a simple blog website…   Your goal is to find the endpoint that generates files holding the server’s memory, where a secret flag is hidden.</p></blockquote><ul><li><code>endpoint</code>：API 的端點，代表可能存在可互動的資料輸出功能。</li><li><code>generates files holding the server’s memory</code>：表示可能會有記憶體快照（heap dump）這類的檔案產生。</li><li><code>flag is hidden</code>：flag 會藏在這些檔案內，不會直接在頁面上顯示。</li></ul><blockquote><p> <strong>結論：</strong> 我們應該找尋網站中與 <strong>API 文件</strong> 或 <strong>系統診斷 &#x2F; 偵錯工具</strong> 相關的頁面或功能。</p></blockquote><hr><h3 id="Step-2-探索網站"><a href="#Step-2-探索網站" class="headerlink" title="Step 2: 探索網站"></a>Step 2: 探索網站</h3><ul><li><p>進入提供的網站後，會發現是一個部落格介面。在其中一篇文章中發現了「API Documentation」的連結，我們點擊進去。</p></li><li><p>點擊進去的畫面會是這樣</p><p> <img src="https://hackmd.io/_uploads/Sklybq2Igl.png" alt="API Documentation Link"></p></li></ul><hr><h3 id="Step-3-使用診斷工具產生記憶體快照"><a href="#Step-3-使用診斷工具產生記憶體快照" class="headerlink" title="Step 3: 使用診斷工具產生記憶體快照"></a>Step 3: 使用診斷工具產生記憶體快照</h3><ul><li><p>在 API 文件頁中，我們找到一個名為 <code>Diagnosing the memory allocation</code> 的功能。</p></li><li><p>點擊 <strong>「執行」</strong> 後，網站會生成一個檔案供下載。</p><p> 📸 範例畫面：<br> <img src="https://hackmd.io/_uploads/r1QYU7C8gx.png" alt="Download Heap Dump"></p><p> <em>下載後會得到一個名為：<em><strong>heapdump-1753261619373.heapsnapshot</strong></em>的檔案。</em></p></li></ul><hr><h2 id="Step-4-解析-heap-dump-檔案找-flag"><a href="#Step-4-解析-heap-dump-檔案找-flag" class="headerlink" title="Step 4: 解析 heap dump 檔案找 flag"></a>Step 4: 解析 heap dump 檔案找 flag</h2><ul><li><h3 id="方法一：使用-Linux-strings-grep-指令"><a href="#方法一：使用-Linux-strings-grep-指令" class="headerlink" title="方法一：使用 Linux strings + grep 指令"></a>方法一：使用 Linux <code>strings</code> + <code>grep</code> 指令</h3><p> 這類 <code>.heapsnapshot</code> 檔案為二進位格式，但裡面可能含有可讀文字，我們可以用 <code>strings</code> 指令提取可見字串，再搭配 <code>grep</code> 過濾出含有 <code>picoCTF</code> 的行：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings heapdump-1753261619373.heapsnapshot | grep picoCTF</span><br></pre></td></tr></table></figure></li><li><h3 id="方法二：使用文字編輯器直接搜尋"><a href="#方法二：使用文字編輯器直接搜尋" class="headerlink" title="方法二：使用文字編輯器直接搜尋"></a>方法二：使用文字編輯器直接搜尋</h3><p> 在圖形化介面下，也可以使用文字編輯器打開檔案（例如 VS Code &#x2F; Sublime &#x2F; Notepad++），然後按下：<code>Ctrl + F</code><br> 搜尋關鍵字 picoCTF，即可快速找到 flag！</p></li></ul><h2 id="🎯-Flag"><a href="#🎯-Flag" class="headerlink" title="🎯 Flag"></a>🎯 Flag</h2><blockquote><p>🟢 <strong>成功取得 Flag！</strong><br> <code>picoCTF&#123;Pat!3nt_15_Th3_K3y_f1179e46&#125;</code></p></blockquote><p><img src="https://img.shields.io/badge/CTF%20Challenge%20-%E2%9C%94%20Completed-brightgreen" alt="Success!"></p><p>🎉 <strong>恭喜你完成這題！繼續加油解鎖更多挑戰吧 💪</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Challenge-head-dump&quot;&gt;&lt;a href=&quot;#Challenge-head-dump&quot; class=&quot;headerlink&quot; title=&quot;Challenge: head-dump&quot;&gt;&lt;/a&gt;Challenge: head-dump&lt;/h1&gt;&lt;bl</summary>
      
    
    
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/categories/PicoCTF/"/>
    
    <category term="Web Exploitation" scheme="https://yowdesert.github.io/categories/PicoCTF/Web-Exploitation/"/>
    
    <category term="Easy" scheme="https://yowdesert.github.io/categories/PicoCTF/Web-Exploitation/Easy/"/>
    
    
    <category term="Web Exploitation" scheme="https://yowdesert.github.io/tags/Web-Exploitation/"/>
    
    <category term="PicoCTF_Easy" scheme="https://yowdesert.github.io/tags/PicoCTF-Easy/"/>
    
    <category term="PicoCTF" scheme="https://yowdesert.github.io/tags/PicoCTF/"/>
    
  </entry>
  
  <entry>
    <title>Blog 簡介</title>
    <link href="https://yowdesert.github.io/posts/undefined.html"/>
    <id>https://yowdesert.github.io/posts/undefined.html</id>
    <published>2025-08-06T07:30:00.000Z</published>
    <updated>2025-08-09T06:44:31.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="👋-Hi，我是-YowDesert"><a href="#👋-Hi，我是-YowDesert" class="headerlink" title="👋 Hi，我是 YowDesert"></a>👋 Hi，我是 YowDesert</h1><p>歡迎來到我的個人部落格！<br>這裡是我在學習旅程中的一個小基地，會記錄下我在程式學習、CTF 解題、工具使用過程中的各種心得與筆記，也會不定期分享生活中的一些想法。</p><hr><h2 id="🧑‍💻-關於我"><a href="#🧑‍💻-關於我" class="headerlink" title="🧑‍💻 關於我"></a>🧑‍💻 關於我</h2><ul><li>🎓 學生 &#x2F; 工程師 &#x2F; 自學者  </li><li>喜歡記錄學習過程中遇到的問題與解法，幫助自己釐清思路，也希望對正在學習的人有所幫助  </li><li>現在在嘗試各種工具與技術（如 Hexo、GitHub Pages、Python、Java…）</li></ul><hr><h2 id="🚀-為什麼創立這個部落格？"><a href="#🚀-為什麼創立這個部落格？" class="headerlink" title="🚀 為什麼創立這個部落格？"></a>🚀 為什麼創立這個部落格？</h2><p>在學習的路上，我經常遇到各種大大小小的問題。<br>這些問題的解法有時藏在一篇文章裡，有時來自他人的經驗分享。<br>我希望能把自己的學習過程與解決問題的方法紀錄下來，<br>不僅幫助自己，也能成為他人搜尋時找到的一盞小燈。</p><p>如果你也正在學習、遇到類似的困難，或許我的經驗能對你有所幫助。<br>如果你對某篇文章有不同想法或更好的做法，也非常歡迎留言交流！</p><hr><h2 id="📝-Blog-未來會分享的內容包括："><a href="#📝-Blog-未來會分享的內容包括：" class="headerlink" title="📝 Blog 未來會分享的內容包括："></a>📝 Blog 未來會分享的內容包括：</h2><ul><li>🔐 <strong>CTF &#x2F; picoCTF 解題筆記與心得</strong></li><li>📚 <strong>學習筆記</strong>（如作業系統、資料結構、計算機網路等）</li><li>🧪 <strong>程式練習紀錄</strong>（演算法、Leetcode、刷題過程）</li><li>🛠 <strong>工具與開發環境教學</strong>（如 VS Code、Git、WSL 等）</li></ul><hr><h2 id="📫-聯絡方式-更多資訊"><a href="#📫-聯絡方式-更多資訊" class="headerlink" title="📫 聯絡方式 &#x2F; 更多資訊"></a>📫 聯絡方式 &#x2F; 更多資訊</h2><ul><li>🔗 GitHub: <a href="https://github.com/YowDesert">https://github.com/YowDesert</a></li><li>💬 歡迎留言、交流與指教！</li></ul><hr><p>感謝你來到這裡 👀<br>Blog 正式上線 🎉<br>未來請多多指教 🙌</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;👋-Hi，我是-YowDesert&quot;&gt;&lt;a href=&quot;#👋-Hi，我是-YowDesert&quot; class=&quot;headerlink&quot; title=&quot;👋 Hi，我是 YowDesert&quot;&gt;&lt;/a&gt;👋 Hi，我是 YowDesert&lt;/h1&gt;&lt;p&gt;歡迎來到我的</summary>
      
    
    
    
    <category term="介紹" scheme="https://yowdesert.github.io/categories/%E4%BB%8B%E7%B4%B9/"/>
    
    
    <category term="自我介紹" scheme="https://yowdesert.github.io/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%B4%B9/"/>
    
    <category term="Blog 開張" scheme="https://yowdesert.github.io/tags/Blog-%E9%96%8B%E5%BC%B5/"/>
    
  </entry>
  
</feed>
